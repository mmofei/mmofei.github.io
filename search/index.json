[{"content":"字体修改 原来的字体看着有点别扭，所以把全站的字体改为了思源宋体，参考了Hugo|月球基地开发历程中的修改全站字体\n在layouts/partials/head/custom.html（没有就重建或者在主题目录下修改）中添加下列代码：\n1\u0026lt;style\u0026gt; 2 :root { 3 --sys-font-family: \u0026#34;Noto Serif SC\u0026#34;; 4 --zh-font-family: \u0026#34;Noto Serif SC\u0026#34;; 5 --base-font-family: \u0026#34;Noto Serif SC\u0026#34;; 6 --code-font-family: \u0026#34;Noto Serif SC\u0026#34;; 7 --article-font-family: \u0026#34;Noto Serif SC\u0026#34;; 8 } 9\u0026lt;/style\u0026gt; 10 11\u0026lt;script\u0026gt; 12 (function () { 13 const customFont = document.createElement(\u0026#34;link\u0026#34;); 14 customFont.href = 15 \u0026#34;https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700\u0026amp;display=swap\u0026#34;; 16 17 customFont.type = \u0026#34;text/css\u0026#34;; 18 customFont.rel = \u0026#34;stylesheet\u0026#34;; 19 20 document.head.appendChild(customFont); 21 })(); 22\u0026lt;/script\u0026gt; 具体的改的有点杂乱，等捋顺思路在添加内容\n","date":"2025-08-14T00:00:00Z","image":"http://localhost:1313/p/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/1_hu_9675c1c049a4df1e.jpeg","permalink":"http://localhost:1313/p/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/","title":"【hugo】| Hugo stack 主题美化"},{"content":"为什么是Hugo？ 很早就想找个平台记录一下自己学习或写的东西，但是由于懒或者是操作不方便都放弃了。最近几个月开始萌生了自己搭建一个博客的想法，所以开始着手搜集这方面的知识，看到了很多炫酷的博客，但是考虑到上手问题，最终选择了hugo，通过挑选，选择了stack这个主题。经历了N多次推倒重建，这个博客终于快装修好了。\n下面记录了我的折腾过程。\n工具准备 hugo git github仓库 hugo 安装 hugo官网提供了多种下载方法，我直接使用的是在github上下载的extended版本 这部分是按照网上的教程进行的，没有踩坑，只需要一步步进行就可以了。\n安装成功后，在cmd中输入hugo version 验证是否安装成功，当输出下面的页面时，即成功了\n主题的选择 hugo 提供了多种主题，我选择了stack主题\n可以使用git 拉取，但是由于网络原因，我选择的是直接在github下载压缩包，让后将其解压到博客目录下的theme中\n然后执行hugo server后，能够在http://localhost:1313/查看到博客，就表示主题应用成功 github部署 截止一步一个本地的博客就搭建好了\n为了可以公开访问，我使用Github Pages进行部署\n此步骤是根据Hugo stack 主题配合Github搭建个人博客教程实现的\n至此，一个个人博客就搭建好了，后续就可以发布文章了。\n接下来，可以按照自己的喜好对主题进行美化，当然也可以选择不修改。看着那么多个性化的博客，我也想装修一个属于自己的赛博空间。\n","date":"2025-08-13T00:00:00Z","image":"http://localhost:1313/p/first-blog/1_hu_cd12862347af94f8.jpg","permalink":"http://localhost:1313/p/first-blog/","title":"【hugo】| 博客开发历程"},{"content":"hjkljklk'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n","date":"2025-08-13T00:00:00Z","image":"http://localhost:1313/p/%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86-%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/2_hu_5fe8a17fbe587ac8.png","permalink":"http://localhost:1313/p/%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86-%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/","title":"【加密和解密】| 动态分析技术"},{"content":"本书基于Windows操作系统\n软件的加密和解密 随着技术的发展，软件加密和解密的研究很有必要。\n软件加密对于开发人员来说，可以保护自己的成果，不轻易被人“借鉴”，但随着技术的不断发展，加密技术也要不断地改进；同时，解密手段也在不断升级。所以，加密和解密是相互促进又相互斗争的关系\n理论上，没有不能破解的加密技术\n所以，作为程序员，研究解密技术可以有助于自己的提升\n逆向分析 逆向工程（Reverse Engineering）是指根据已有的产物和结果，通过分析来推导出具体的实现方法\n逆向工程：可执行程序\u0026ndash;\u0026gt;反编译\u0026ndash;\u0026gt;源代码\n逆向工程的内容分类：\n软件使用的限制的去除或软件功能的天际 软件源代码的再获得 硬件的复现和模拟 逆向分析技术 软件汉化和解密首先要对软件进行分析，对他们的分析可以遵循下面几种方法：\n1、通过软件格式使用说明和操作格式分析软件 分析一个软件，需要先学会这个软件。通过阅读软件的使用手册，学习软件操作并了解软件的功能。经验丰富的程序分析师，能够通过软件的使用说明和操作推测出软件的设计思想和编程思路\n2、静态分析技术 静态分析指根据反汇编得到的程序清单进行分析，常用方法从提示信息入手进行分析。\n原因：现在大多数软件采用人机对话方式设计\n人机对话：软件运行时出现需要用户操作的提示信息，并且在执行某段程序之后显示提示信息来反映该段程序的运行状态或者是提示下一步操作\n因此，阅读通过静态反汇编得到的程序清单，根据包含提示信息的程序片段，可以知道提示信息前后的程序片段所完成的功能，从而宏观了解软件的编程思维\n常用的静态分析工具 IDA\n3、动态分析技术 静态分析可以了解各个模块的功能，以及整个软件的编程思路，但是不能了解软件中各个模块的技术细节\n对于软件分析来说，静态分析只是第一步，动态跟踪才是分析软件的关键。\n动态跟踪主要是指利用OllyDbg或WinDbg等调试工具，一步步跟踪分析\n为什么要对软件进行动态分析 一般软件要分解成若干个模块来实现，后一个模块的执行依赖于前一个模块处理的结果，这个结果也称为中间结果。如果只进行静态分析，很难获得这个中间结果，只有跟踪前一个模块，才能看到这些结果。另外，触发程序执行的条件有多个分支，如果不动态跟踪，很难的得知程序的执行路径 许多软件运行时，最初执行的一段程序需要对后面的各个模块进行一些初始化工作，并不依赖系统的重定位 ？？这个地方有点不懂\n加密程序在运行时会采用逐块解密、逐块执行的方法。仅对软件的密码部分进行返回百年，而不对该软件进行动态跟踪分析，是根本不可能进行解密的 如何有效进行动态分析 动态分析主要包括两点：\n对软件进行粗跟踪 粗跟踪是指在跟踪时要大块大块地跟踪。\n在遇到调用指令（CALL）、重复操作指令（REP）、循环操作指令（LOOP）等时一般不要跟踪，而要根据执行结果分析该段程序的功能\n粗跟踪的原因：\n一般软件划分为若干模块，在分析一个软件时，主要分析的是软件中所关心的部分，然而软件最初执行的模块通常不是我们所关心的 这里涉及合理设置断点，需要了解Win32 API函数，根据当时的情况选择合适的断点\n对关键部分进行细跟踪 对软件进行一定程度的粗跟踪之后，就能获取软件中我们所关心的模块或程序段了，这样就可以有针对性地对该模块进行具体而详细的跟踪结果。一般，可以要进行对此关键代码分析，并将每次关键的中间结果或指令地址记录下来（养成良好的操作习惯）\nWindows操作系统 Windows x86系列CPU采用的是小端序字节存储位置，即低位字节存放在低位地址，高位字节存放在高位地址\nWin32 API函数 API(Application Programming Interface,应用程序编程接口)\n早期，Windows程序设计只能使用API函数进行编程，这些函数提供应用程序运行所需要的窗口管理、图形设备接口、内存管理等服务功能，这些服务以函数库库的形式组织在一起，形成了Win API\n也可以认为API函数是整个Windows框架的基石，下面是Windows操作系统核心，上面是Windows应用程序： Win16: 16位Windows的API\nWin32: 32位Windows的API, 64位Windows API的名称和功能基本没有变化，还是使用Win32的函数名，只是用64位代码实现的\nWindows运转的核心是动态链接库（DLL）\n早期，Windows的主要部分只需要在3个动态链接库中实现：\nKernel(KERNEL32.DLL实现)：操作系统核心功能服务，包括进程和线程控制、内存管理、文件访问等 User（USER32.DLL实现）：负责处理用户接口，包括键盘和鼠标输入、窗口和菜单管理等 GDI（GDI32.DLL实现）：图形设备接口，允许程序在屏幕和打印机上显示文本和图形 除了上述模块，Windows提供了其他DLL以支持更多的功能：\n对象安全性 注册表操作（ADVAPI32.DLL） 通用控件（COMCTL32.DLL） 公共对话框（COMDLG32.DLL） 用户界面外壳（SHELL32.DLL） 网络（NETAPI32.DLL） Win API是基于C语言的接口，但可以由不同语言编写的程序调用，只要遵循调用规范即可\n在NT结构下，Win32 API 接受Unicode和ASCII两种字符集，而其内核只能使用Unicode字符集\nASCII字符集\nUnicode字符集\n在Win32　API函数字符集中，A表示ANSI（即ASCII），W表示Widechars(即nicode)\nANSI 使用单字节方式\nUnicode是宽字节方式，以便处理双字节字符\n每个以字节为参数的Win32 函数在操作系统中都有着两种方式的版本\n例如：MessageBox函数(此函数用于在USER32.DLL用户模块中创建和显示信息框)\n函数原型：\n1int MessageBox( 2 HWND hWnd, //父窗口句柄 3 LPCTSTR lpText, //消息框文本地址 4 LPCTSTR lpCaption, //消息框标题地址 5 UINT uType //消息框样式 6); Windows 2000中的MessageBoxA函数的内部结构：\n1int MessageBoxA( 2 MessageBoxExA{ //调用MessageBoxExA函数 3 MBToWCSEx() //将MessageBoxA消息框的主体文字转换成Unicode字符串 4 MBT0WCSEx() //将将MessageBoxA消息框标题栏上的文字转换成Unicode字符串 5 MessageBoxExW() //调用MessageBoxExW函数 6 HeapFree() //释放内存 7 8 } 9); 上面的结果表明，MessageBoxExA函数其实是一个替换翻译层，用于分配内存，并将ANSI字符串转换成Unicode字符串，系统最终调用Unicode版的MessageBoxExW函数执行。当MessageBoxExW函数返回时，它便释放内存缓存\nwin32 API程序大量调用系统提供的API函数，而Win32平台上的调试器（OllyDbg等）恰好有针对API函数设置断点的强大功能\nWOW64 WOW64(Windows-on-Windows 64-bit)是64位Windows操作系统的子系统，可以使大多数32位应用程序在不进行修改的情况下运行在64位操作系统上\n64位Windows（包含64位操作系统应有的系统文件和32位操作系统应用的系统文件）：\nSystem32文件夹\u0026ndash;包含原生的64位映像文件 SysWOW64文件夹\u0026ndash;存储32位的系统文件 64位应用程序会加载System32目录下64位的kernel32.dll、user32.dll、ntdll.dll\n32位应用程序加载时，WOW64建立32位ntdll.dll所要求的启动环境，将CPU模式切换为32位，并开始执行32位加载器，像运行在32位机器上一样\nWOW64会对32位ntdll.dll的调用重定向ntdll.dll(64位)，而不是发出原生的32位系统调用指令\nWOW64转换到原生的64位模式，捕获与系统调用有关的参数，发出对应的原生64位系统调用。当原生的系统调用返回时，WOW64在返回32位模式之前将所有输出参数从64位转换成32位\nWOW64进程只能加载32为的DLL，不能加载原生的64位DLL\nWindows 消息机制 虚拟内存 ","date":"2025-08-13T00:00:00Z","image":"http://localhost:1313/p/%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86%E5%A4%8D%E7%9B%98%E7%AC%94%E8%AE%B0/1_hu_5fe8a17fbe587ac8.png","permalink":"http://localhost:1313/p/%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86%E5%A4%8D%E7%9B%98%E7%AC%94%E8%AE%B0/","title":"【加密和解密】| 基础篇"}]