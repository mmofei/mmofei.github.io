[{"content":"导语 我没有经过系统的训练，记录一下在小红书学到的知识\n摄影眼提高方法 ","date":"2025-09-07T00:00:00Z","image":"http://localhost:1313/p/%E5%AD%A6%E4%B9%A0%E6%91%84%E5%BD%B1%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%BC%9A%E6%8B%8D%E7%85%A7/1_hu_8daa40e89b7eb96.jpg","permalink":"http://localhost:1313/p/%E5%AD%A6%E4%B9%A0%E6%91%84%E5%BD%B1%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%BC%9A%E6%8B%8D%E7%85%A7/","title":"摄影 | 摄影眼的养成"},{"content":"导读 放弃一切错误方法，开始“刻意练习”\n重点内容 ","date":"2025-09-04T00:00:00Z","image":"http://localhost:1313/p/%E8%AF%BB%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6%E5%9C%A8%E4%B9%A6%E4%B8%AD%E4%B8%B0%E5%AF%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86/1_hu_68aca28ecd46e5b3.jpg","permalink":"http://localhost:1313/p/%E8%AF%BB%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6%E5%9C%A8%E4%B9%A6%E4%B8%AD%E4%B8%B0%E5%AF%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86/","title":"好书阅读| 刻意练习"},{"content":"","date":"2025-08-26T00:00:00Z","permalink":"http://localhost:1313/p/%E5%BF%85%E5%AD%A6%E7%9F%A5%E8%AF%86/","title":"小白整理必学知识1"},{"content":"导语 最近发现自己的知识体系有点混乱，感觉什么都学了，但是什么都没学会。借这篇文章整理下自己的思路，顺便系统学习一下什么是CTF\nCTF CTF（Capture The Flag），夺旗赛。参赛方通过攻防对抗、程序分析等形式，率先从主办方的给出的比赛环境中得到一串具有一定格式的字符串或其他内容，并提交给主办方，从而夺得分数。这串内容为Flag\n比赛内容 Reverse（逆向类）：对软件的结构、流程、算法等进行逆向破解 要求：较强的反汇编、反编译的能力 所需知识：汇编语言、加密与解密、常见的反编译工具 Pwn（溢出类） 常见的类型：整数溢出u、栈溢出、堆溢出等 要求：考查对漏洞的利用能力 所需知识：C、OD+IDA、数据机构、操作系统 Web（Web漏洞类） 常见类型： XSS、文件包含、代码执行、上传漏洞、SQL注入等，也有些简单的关于网络基础知识的考察：如返回包、TCP/IP、数据包内容和构造 所需知识：PHP、Python、TCP/IP、SQL Crypto（加密类）：考察这种加解密技术 要求：考查密码学相关知识点 所需知识： 矩阵、数论、密码学 Mobile 要求：涉及Android和iOS两个平台，主要是Android逆向，破解APK并提交正确flag 所需知识： Java、Android开发、常用工具 Misc（杂项） 常见题目：隐写术、电子取证、人肉搜索、数据分析、大数据统计等 所需知识: 常见隐写术工具、Wireshark等流量审查工具、编码知识 二进制安全 二进制安全是一盒比较偏向底层的方向，对计算机基础要求较高\nC/C++ Python 汇编语言 计算机组成原理 操作系统 编译原理 二进制安全可以细分为逆向工程和漏洞挖掘与利用等方向\n学习书籍推荐（中文）：\n程序员的自我修养\u0026ndash;链接、装载与库 加密和解密（第四版） 学完之后，就可以进行软件漏洞的学习了，分析真实环境中的漏洞和恶意样本，推荐资料：\n漏洞战争“软件漏洞分析精要 有了实践基础之后，可以学习一些理论分析：\n数据流分析（Soot） 值集分析（BAP） 可满足性（Z3） 动态二进制插桩 符号执行 模糊测试 二进制文件 源文件\u0026ndash;\u0026gt;可执行文件 一个C语言程序从源文件开始，这种高级语言的形式更容易被人理解。但是程序运行，每条C语句都必须翻译为一系列的低级机器语言指令。最后，这些指令按照可执行目标文件的格式打包，并以二进制的形式存放起来\n编译原理 编程语言\u0026ndash;\u0026gt;编译器\u0026mdash;\u0026gt;目标语言\nGCC编译过程 预处理（hello.c\u0026ndash;\u0026gt;hello.i） 处理源代码中以“#”开始的预处理指令，如#include、#define，将其转换后直接插入程序文本中，得到另一个C程序hello.i 在命令中添加编译选-E 可以单独执行预处理 一些预处理规则 #include：将对应文件的内容复制到该指令的位置（换行后的内容原封不动的出现在下面） #define 删除，并且在被引用的位置递归地扩展所有的宏定义（即原本文件中的数据使用的是宏，但之后会变成数字） 处理所有条件预处理指令：if、ifdef、elif、else、endif等 删除所有注释 添加行号和文件名标识 编译(hello.i\u0026ndash;\u0026gt;hello.s) 此过程将预处理文件进行一系列的词法分析、语法分析、语义分析以及优化，最终生成汇编代码 在命令中添加编译选项-S,操作对象可以是源代码 hello.c，也可以是hello.i 注：生成的汇编代码中函数printf()被替换为puts(),因为当printf()只有单一参数时，与puts()功能类似 汇编(hello.s\u0026ndash;\u0026gt;hello.o) 汇编器根据汇编指令与机器指令的对照表进行翻译，将hello.s汇编成目标文件hello.o hello.o是一个可重定位文件，可以使用objdump命令来查看其内容 链接(hello.o\u0026ndash;\u0026gt;hello) 链接器collect2是对ld命令的封装，用于将C语言运行时库（CRT）中的目标文件(crt1.o,crti.o,crtbegin.o,crtend.o,crtn,o)以及所需的动态链接库链接到可执行hello 分类 静态链接\u0026mdash; 添加编译选项-static即可指定使用静态链接 动态链接（默认） 此阶段将目标文件及其依赖库进行链接，生成可执行文件，主要包括地址和空间分配、符号绑定和重定位等操作 链接操作由链接器（ld.so）完成，得到hello文件，这是一个静态链接的可执行文件，包含大量的库文件 通过链接操作，对象文件中无法确定的符号地址已经被修正为实际的符号地址，程序就可以被加载到内存中正常执行了 ELF文件格式 ELF（Executable and Linkable Format）:可执行可链接格式\nELF分类：\n可执行文件（.exec） 经过链接的、可执行的目标文件，通常称为程序 可重定位文件（.rel） 由源文件编译而成尚未链接的目标文件，通常以“.o”作为扩展名。通常是一段位置独立的代码 共享目标文件（.dyn） 动态链接库文件 核心转储文件（core dump file） 作为进程意外终止时进程地址空间的转储，也是ELF文件的一种，使用gdb读取这类文件可以辅助调试和查找程序崩溃的原因（在Linux中遇到过核心转储问题） 注：ELF文件被统称为Object file，所以ELF可以认定为目标文件，而“.o”文件可以称为重定位文件\nELF文件的结构：\n审视目标文件的两种视角\n链接视角 通过节（Section）来进行划分\n目标文件中包含的节\n代码（.text）:保存可执行的机器指令\n.text的数据是十六制形式，共0x4e个字节 偏移量（最左一列） 内容（中间四列） ASCII码（最右一列） 数据（.data）：保存已初始化的全局变量和局部静态变量\n.data中是源代码中的变量 .rodata 保存只读数据（只读变量和字符串常量） BSS（.bss）：保存未初始化的全局变量和局部静态变量\n其他常见的节：\n.strtab(字符串表) 包含了以null结尾的字符序列，用来表示符合和节名，引用字符串时只需给出字符序列在表中的偏移即可 symtab(符号表) 记录目标文件中所有用到的所有符号信息，通常分为.dynsym和.symtab，前者是后者的子集 .dynsym：保存了引用自外部文件的符号，只能在运行时被解析 .symtab：还保存了本地符号，用于调试和链接 目标文件通过一个符号在表中的索引值来使用该符号 （重定位）：链接符号定义与符号引用的过程 可重定位文件在构建可执行文件或共享目标文件时，需要把节中的符号引用换成这些符号在进程空间中的虚拟地址 ELF文件头：位于目标文件最开始的位置，包含描述整个文件的一些基本信息\nELF文件类型 版本/应用程序二进制接口ABI版本 目标机器 程序入口 段表和节表的位置和长度等 节头表：存储目标文件中各个节的信息 表的每一项都是一个Elf64_Shdr结构体（节描述符），记录节的名字、长度、偏移、读写权限等信息 节头表的位置记录在文件头的e_shoff域中 在运行时节头表不是必须的，所以常有程序去除节头表，以增加反编译器的分析难度 文件头存在魔术字符（7f 45 4c 46）,即字符“\\177ELF”,当文件被映射到内存时，可以通过搜索该字符确定映射地址，在dump内存时非常有用\n指令和数据分别存放的好处：防止程序指令被改写和利用\n运行视角 通过段（Segment）来进行划分 运行可执行文件时，首先需要将该文件和动态链接库装载到进程空间中，形成进程镜像 每个进程拥有独立的虚拟地址空间，这个空间布局由记录在段头表中的程序头决定的 段表头位置：ELF文件头的e_phoof域已给出 ","date":"2025-08-19T00:00:00Z","image":"http://localhost:1313/p/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93%E4%BD%93%E7%B3%BB/1_hu_15f9b051f0ac136f.jpg","permalink":"http://localhost:1313/p/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93%E4%BD%93%E7%B3%BB/","title":"前置知识整理"},{"content":"导语 玩了这个游戏很久了，想要记录一下。\n开始的时候来源于朋友的推荐，自己没有好好了解过这个游戏，玩的都是稀里糊涂的。现在想深度了解下这个游戏\n官方简介 《桃源深处有人家》是一款悠然治愈的国风山水田园经营手游。回到心中的故乡，远离尘世，过一份安静恬淡的小生活。在这里，有活泼淘气的妹妹陪伴在身边；有可爱神奇的萝卜山灵与你一同生活；有迷失在幻境中寻求解忧的灵魂；还有那居住在山下似曾相识的故人们……\n归来的人，终会发现最美的风景。\n耕作经营——建设专属于你的世外桃源 归园田居——享受安静恬淡的山居生活 古韵悠然——品味青绿山水的国风画卷 萌物陪伴——邂逅性格迥异的可爱萝卜 桃源一梦——探索动人心弦的神秘故事\n在这里，你将伴随哥哥妹妹，一同回到童年的小茅屋 你可以和小萝卜们一起耕地种植，建设自己温馨的田园小家 也可以在清风明月下备一桌好菜，和村民们聊聊温暖的故事 在这里，你可以放下心中杂念 看山中花开花谢，品云间星月流转 洗去繁华与浮躁，偷得浮生半日闲 在恬淡悠然的山居生活中 重拾内心的那份安宁与平静\n总结：一款治愈系的模拟经营游戏，偏向治愈系。借用开发者的话：在玩过之后可以退回到当初的样子，像游戏里的小萝卜一样，对这个世界充满好奇心和童真 萝萝山大赏 萝萝农场 扶光和陶陶居所的所在地\n博物山 仙女湖 萝萝古镇 介绍游戏有点复杂，还是接着做壁纸吧\n","date":"2025-08-17T00:00:00Z","image":"http://localhost:1313/p/%E6%A1%83%E6%BA%90%E6%B7%B1%E5%A4%84%E6%9C%89%E4%BA%BA%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%AE%B0%E5%BD%95/1_hu_1c67d55725d25302.jpg","permalink":"http://localhost:1313/p/%E6%A1%83%E6%BA%90%E6%B7%B1%E5%A4%84%E6%9C%89%E4%BA%BA%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%AE%B0%E5%BD%95/","title":"【游戏专区】| 桃源深处有人家（1）"},{"content":"导语 最近看到很多好看的分区壁纸，想要自己做一下，那桃源的图片练了下手，感觉做的还可以，在博客里面贴一下，如果想要的话可以在小红书@莫非领取\n展示成果 ","date":"2025-08-17T00:00:00Z","image":"http://localhost:1313/p/%E6%A1%83%E6%BA%90%E6%B7%B1%E5%A4%84%E6%9C%89%E4%BA%BA%E5%AE%B6%E7%94%B5%E8%84%91%E5%88%86%E5%8C%BA%E5%A3%81%E7%BA%B8%E5%8F%AF%E5%9C%A8%E5%B0%8F%E7%BA%A2%E4%B9%A6@%E8%8E%AB%E9%9D%9E%E9%A2%86%E5%8F%96/swiper3-img4_hu_a7bbfead1c6490a6.webp","permalink":"http://localhost:1313/p/%E6%A1%83%E6%BA%90%E6%B7%B1%E5%A4%84%E6%9C%89%E4%BA%BA%E5%AE%B6%E7%94%B5%E8%84%91%E5%88%86%E5%8C%BA%E5%A3%81%E7%BA%B8%E5%8F%AF%E5%9C%A8%E5%B0%8F%E7%BA%A2%E4%B9%A6@%E8%8E%AB%E9%9D%9E%E9%A2%86%E5%8F%96/","title":"【游戏专区】| 桃源深处有人家（2）"},{"content":"导语 网络爬虫作为一种自动采集数据的技术，凭借吱声强大的自动抓取网页数据的能力，成为当下互联网高效、灵活的解决方法之一\n什么是网络爬虫 网络爬虫（Web Crawler）是一种按照一定规则，自动请求网站并提取网页数据的程序和脚本\n按照系统结构和实现即时可以分为以下几种类型：\n通用网络爬虫\n搜索引擎抓取系统的重要组成部分，在本地形成一个互联网网页的镜像备份、 数量巨大且范围广泛 爬行速度和存储空间要求高，但对抓取网页的顺序的要求相对较低 聚焦网络爬虫\n针对特定目标，有选择性的访问与目标主题相关的网页 减少了访问和保存的页面数量，提高网页的更新速度 增量式网络爬虫\n抓取已下载的网页中新产生或内容变化的网页 减少网页的下载量和访问时间，以及减少存储空间的耗费 增加了网页抓取算法的复杂度和实现难度 深层网络爬虫\n抓取网页层次较深，需要通过一定的附加策略才能自动抓取，实现难度大 表层网页和深层网页\n","date":"2025-08-16T00:00:00Z","image":"http://localhost:1313/p/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/OIP-C_hu_7497c38f10f77ec9.webp","permalink":"http://localhost:1313/p/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/","title":"【网络爬虫】| python 爬虫"},{"content":"动态分析技术中最重要的工具是调试器，分为用户模式和内核模式两种类型：\n用户模式调试器:用来调试用户模式应用程序的调试器，工作在Ring3级。例如，OllyDbg、x64dbg、VC++等编译器自带的调试器 内核模式调试器：能调试操作系统内核的调试器。例如，WinDbg Ring3级\nOllyDbg OllyDbg(OD)是一款具有可视化界面的用户模式调试器，可以运行在各个版本的Windows上，但NT架构更加稳定。它结合了动态调试和静态分析，具有GUI界面，非常容易上手，对异常的跟踪处理相当灵活。\nx64dbg MDebug WinDbg ","date":"2025-08-15T00:00:00Z","image":"http://localhost:1313/p/%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86-%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/2_hu_5fe8a17fbe587ac8.png","permalink":"http://localhost:1313/p/%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86-%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/","title":"【加密和解密】| 动态分析技术"},{"content":"字体修改 原来的字体看着有点别扭，所以把全站的字体改为了思源宋体，参考了Hugo|月球基地开发历程中的修改全站字体\n在layouts/partials/head/custom.html（没有就重建或者在主题目录下修改）中添加下列代码：\n1\u0026lt;style\u0026gt; 2 :root { 3 --sys-font-family: \u0026#34;Noto Serif SC\u0026#34;; 4 --zh-font-family: \u0026#34;Noto Serif SC\u0026#34;; 5 --base-font-family: \u0026#34;Noto Serif SC\u0026#34;; 6 --code-font-family: \u0026#34;Noto Serif SC\u0026#34;; 7 --article-font-family: \u0026#34;Noto Serif SC\u0026#34;; 8 } 9\u0026lt;/style\u0026gt; 10 11\u0026lt;script\u0026gt; 12 (function () { 13 const customFont = document.createElement(\u0026#34;link\u0026#34;); 14 customFont.href = 15 \u0026#34;https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700\u0026amp;display=swap\u0026#34;; 16 17 customFont.type = \u0026#34;text/css\u0026#34;; 18 customFont.rel = \u0026#34;stylesheet\u0026#34;; 19 20 document.head.appendChild(customFont); 21 })(); 22\u0026lt;/script\u0026gt; 具体的改的有点杂乱，等捋顺思路在添加内容\n","date":"2025-08-14T00:00:00Z","image":"http://localhost:1313/p/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/1_hu_9675c1c049a4df1e.jpeg","permalink":"http://localhost:1313/p/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/","title":"【hugo】| Hugo stack 主题美化"},{"content":"为什么是Hugo？ 很早就想找个平台记录一下自己学习或写的东西，但是由于懒或者是操作不方便都放弃了。最近几个月开始萌生了自己搭建一个博客的想法，所以开始着手搜集这方面的知识，看到了很多炫酷的博客，但是考虑到上手问题，最终选择了hugo，通过挑选，选择了stack这个主题。经历了N多次推倒重建，这个博客终于快装修好了。\n下面记录了我的折腾过程。\n工具准备 hugo git github仓库 hugo 安装 hugo官网提供了多种下载方法，我直接使用的是在github上下载的extended版本 这部分是按照网上的教程进行的，没有踩坑，只需要一步步进行就可以了。\n安装成功后，在cmd中输入hugo version 验证是否安装成功，当输出下面的页面时，即成功了\n主题的选择 hugo 提供了多种主题，我选择了stack主题\n可以使用git 拉取，但是由于网络原因，我选择的是直接在github下载压缩包，让后将其解压到博客目录下的theme中\n然后执行hugo server后，能够在http://localhost:1313/查看到博客，就表示主题应用成功 github部署 截止一步一个本地的博客就搭建好了\n为了可以公开访问，我使用Github Pages进行部署\n此步骤是根据Hugo stack 主题配合Github搭建个人博客教程实现的\n至此，一个个人博客就搭建好了，后续就可以发布文章了。\n接下来，可以按照自己的喜好对主题进行美化，当然也可以选择不修改。看着那么多个性化的博客，我也想装修一个属于自己的赛博空间。\n","date":"2025-08-13T00:00:00Z","image":"http://localhost:1313/p/first-blog/1_hu_cd12862347af94f8.jpg","permalink":"http://localhost:1313/p/first-blog/","title":"【hugo】| 博客开发历程"},{"content":"本书基于Windows操作系统\n软件的加密和解密 随着技术的发展，软件加密和解密的研究很有必要。\n软件加密对于开发人员来说，可以保护自己的成果，不轻易被人“借鉴”，但随着技术的不断发展，加密技术也要不断地改进；同时，解密手段也在不断升级。所以，加密和解密是相互促进又相互斗争的关系\n理论上，没有不能破解的加密技术\n所以，作为程序员，研究解密技术可以有助于自己的提升\n逆向分析 逆向工程（Reverse Engineering）是指根据已有的产物和结果，通过分析来推导出具体的实现方法\n逆向工程：可执行程序\u0026ndash;\u0026gt;反编译\u0026ndash;\u0026gt;源代码\n逆向工程的内容分类：\n软件使用的限制的去除或软件功能的天际 软件源代码的再获得 硬件的复现和模拟 逆向分析技术 软件汉化和解密首先要对软件进行分析，对他们的分析可以遵循下面几种方法：\n1、通过软件格式使用说明和操作格式分析软件 分析一个软件，需要先学会这个软件。通过阅读软件的使用手册，学习软件操作并了解软件的功能。经验丰富的程序分析师，能够通过软件的使用说明和操作推测出软件的设计思想和编程思路\n2、静态分析技术 静态分析指根据反汇编得到的程序清单进行分析，常用方法从提示信息入手进行分析。\n原因：现在大多数软件采用人机对话方式设计\n人机对话：软件运行时出现需要用户操作的提示信息，并且在执行某段程序之后显示提示信息来反映该段程序的运行状态或者是提示下一步操作\n因此，阅读通过静态反汇编得到的程序清单，根据包含提示信息的程序片段，可以知道提示信息前后的程序片段所完成的功能，从而宏观了解软件的编程思维\n常用的静态分析工具 IDA\n3、动态分析技术 静态分析可以了解各个模块的功能，以及整个软件的编程思路，但是不能了解软件中各个模块的技术细节\n对于软件分析来说，静态分析只是第一步，动态跟踪才是分析软件的关键。\n动态跟踪主要是指利用OllyDbg或WinDbg等调试工具，一步步跟踪分析\n为什么要对软件进行动态分析 一般软件要分解成若干个模块来实现，后一个模块的执行依赖于前一个模块处理的结果，这个结果也称为中间结果。如果只进行静态分析，很难获得这个中间结果，只有跟踪前一个模块，才能看到这些结果。另外，触发程序执行的条件有多个分支，如果不动态跟踪，很难的得知程序的执行路径 许多软件运行时，最初执行的一段程序需要对后面的各个模块进行一些初始化工作，并不依赖系统的重定位 ？？这个地方有点不懂\n加密程序在运行时会采用逐块解密、逐块执行的方法。仅对软件的密码部分进行返回百年，而不对该软件进行动态跟踪分析，是根本不可能进行解密的 如何有效进行动态分析 动态分析主要包括两点：\n对软件进行粗跟踪 粗跟踪是指在跟踪时要大块大块地跟踪。\n在遇到调用指令（CALL）、重复操作指令（REP）、循环操作指令（LOOP）等时一般不要跟踪，而要根据执行结果分析该段程序的功能\n粗跟踪的原因：\n一般软件划分为若干模块，在分析一个软件时，主要分析的是软件中所关心的部分，然而软件最初执行的模块通常不是我们所关心的 这里涉及合理设置断点，需要了解Win32 API函数，根据当时的情况选择合适的断点\n对关键部分进行细跟踪 对软件进行一定程度的粗跟踪之后，就能获取软件中我们所关心的模块或程序段了，这样就可以有针对性地对该模块进行具体而详细的跟踪结果。一般，可以要进行对此关键代码分析，并将每次关键的中间结果或指令地址记录下来（养成良好的操作习惯）\nWindows操作系统 Windows x86系列CPU采用的是小端序字节存储位置，即低位字节存放在低位地址，高位字节存放在高位地址\nWin32 API函数 API(Application Programming Interface,应用程序编程接口)\n早期，Windows程序设计只能使用API函数进行编程，这些函数提供应用程序运行所需要的窗口管理、图形设备接口、内存管理等服务功能，这些服务以函数库库的形式组织在一起，形成了Win API\n也可以认为API函数是整个Windows框架的基石，下面是Windows操作系统核心，上面是Windows应用程序： Win16: 16位Windows的API\nWin32: 32位Windows的API, 64位Windows API的名称和功能基本没有变化，还是使用Win32的函数名，只是用64位代码实现的\nWindows运转的核心是动态链接库（DLL）\n早期，Windows的主要部分只需要在3个动态链接库中实现：\nKernel(KERNEL32.DLL实现)：操作系统核心功能服务，包括进程和线程控制、内存管理、文件访问等 User（USER32.DLL实现）：负责处理用户接口，包括键盘和鼠标输入、窗口和菜单管理等 GDI（GDI32.DLL实现）：图形设备接口，允许程序在屏幕和打印机上显示文本和图形 除了上述模块，Windows提供了其他DLL以支持更多的功能：\n对象安全性 注册表操作（ADVAPI32.DLL） 通用控件（COMCTL32.DLL） 公共对话框（COMDLG32.DLL） 用户界面外壳（SHELL32.DLL） 网络（NETAPI32.DLL） Win API是基于C语言的接口，但可以由不同语言编写的程序调用，只要遵循调用规范即可\n在NT结构下，Win32 API 接受Unicode和ASCII两种字符集，而其内核只能使用Unicode字符集\nASCII字符集\nUnicode字符集\n在Win32　API函数字符集中，A表示ANSI（即ASCII），W表示Widechars(即nicode)\nANSI 使用单字节方式\nUnicode是宽字节方式，以便处理双字节字符\n每个以字节为参数的Win32 函数在操作系统中都有着两种方式的版本\n例如：MessageBox函数(此函数用于在USER32.DLL用户模块中创建和显示信息框)\n函数原型：\n1int MessageBox( 2 HWND hWnd, //父窗口句柄 3 LPCTSTR lpText, //消息框文本地址 4 LPCTSTR lpCaption, //消息框标题地址 5 UINT uType //消息框样式 6); Windows 2000中的MessageBoxA函数的内部结构：\n1int MessageBoxA( 2 MessageBoxExA{ //调用MessageBoxExA函数 3 MBToWCSEx() //将MessageBoxA消息框的主体文字转换成Unicode字符串 4 MBT0WCSEx() //将将MessageBoxA消息框标题栏上的文字转换成Unicode字符串 5 MessageBoxExW() //调用MessageBoxExW函数 6 HeapFree() //释放内存 7 8 } 9); 上面的结果表明，MessageBoxExA函数其实是一个替换翻译层，用于分配内存，并将ANSI字符串转换成Unicode字符串，系统最终调用Unicode版的MessageBoxExW函数执行。当MessageBoxExW函数返回时，它便释放内存缓存\nwin32 API程序大量调用系统提供的API函数，而Win32平台上的调试器（OllyDbg等）恰好有针对API函数设置断点的强大功能\nWOW64 WOW64(Windows-on-Windows 64-bit)是64位Windows操作系统的子系统，可以使大多数32位应用程序在不进行修改的情况下运行在64位操作系统上\n64位Windows（包含64位操作系统应有的系统文件和32位操作系统应用的系统文件）：\nSystem32文件夹\u0026ndash;包含原生的64位映像文件 SysWOW64文件夹\u0026ndash;存储32位的系统文件 64位应用程序会加载System32目录下64位的kernel32.dll、user32.dll、ntdll.dll\n32位应用程序加载时，WOW64建立32位ntdll.dll所要求的启动环境，将CPU模式切换为32位，并开始执行32位加载器，像运行在32位机器上一样\nWOW64会对32位ntdll.dll的调用重定向ntdll.dll(64位)，而不是发出原生的32位系统调用指令\nWOW64转换到原生的64位模式，捕获与系统调用有关的参数，发出对应的原生64位系统调用。当原生的系统调用返回时，WOW64在返回32位模式之前将所有输出参数从64位转换成32位\nWOW64进程只能加载32为的DLL，不能加载原生的64位DLL\n类似，原生的64位进程不能加载32为的DLL\nWindows 消息机制 Windows是一个消息（Message）驱动式系统,Windows消息提供在应用程序与应用程序之间、应用程序与Windows系统之间进行通信的手段\n应用程序想要实现的功能需要由消息触发，通过对消息的响应和处理完成\nWindows系统的两种消息队列：\n系统消息队列 应用程序消息队列 计算机的所有输入设备由Windows监控\n一个事件从发生到到达处理它的窗口函数的过程：\n当一个事件发生时，Windows先将输入的消息放入系统消息队列，再将输入的消息复制到相应的应用程序队列中，应用程序中的消息循环在它的消息队列中检索每个消息并发给相应的窗口函数\n注：消息的非抢先性，即事件不论轻重缓急，总是按达到的先后排队，而这会导致一些外部实时事件得不到及时的处理\nWindows常用的消息函数：\nSendMessage 函数 调用一个窗口的窗口函数，将一天消息发给那个窗口。除非消息处理完毕，否则该函数不会返回。 函数示例： 1LRESULT SendMessage( 2 HWND hWnd, 3 UNIT Msg, 4 WPARAM wParam, 5 LAPRAM lParam 6); 返回值由具体的消息决定。如果消息传递成功，则返回True WM_COMMAND消息 WM_DESTROY消息 WM_GETTEXT消息 WM_QUIT消息 WM_LBUTTONDOWN消息 虚拟内存 虚拟内存（Virtual Memory）不是真正的内存，它通过映射（Map）的方法使用可用虚拟地址（Virtual Address）达到4GB（默认情况下，32位Windows操作系统的地址空间在4GB以内），每个应用程序可以获得2GB的虚拟地址，剩下的2GB留给操作系统自用\nWIndows操作系统是一个分时的多任务操作系统，CPU时间在被分成一个个时间片后分配给不同的程序。在一个时间片里，与这个程序的执行无关的内容不会映射到线性地址中。因此，每个程序都有自己的4GB寻址空间，互不干扰。\n虚拟内存的实现方法：\n一个应用程序启动时，操作系统就创建一个进程，并给该进程分配2GB的虚拟地址（不是内存，只是地址） 虚拟内存管理器将应用程序的代码映射到那个应用程序的虚拟地址中的某个位置，并把当前需要的代码读入物理地址 虚拟地址与应用程序代码在屋里内存中的位置是没有关系的\n如果使用DLL，DLL也会被映射到进程的虚拟地址空间中，在需要的时候才会被读入物理内存 其他项目（数据、堆栈等）的空间也是从物理内存中分配的，并被映射到虚拟地址空间中 应用程序通过使用其他虚拟地址空间中的地址开始执行。然后，虚拟内存内管理器把每次内存访问映射到物理位置 注：\n应用程序不会直接访问物理地址 虚拟内存管理器通过虚拟地址的访问请求来控制所有的物理地址访问 每个应用程序都有独立的4GB寻址空间，不同的应用程序的地址空间相互不影响 DLL总是被映射到其他应用程序的地址空间中，作为其他应用程序的一部分（原因：如果DLL不与其他程序处于同一地址空间，应用程序就无法调用） 使用虚拟内存可以简化内存的管理，弥补物理内存的不足，可以防止多任务环境相爱应用程序之间的冲突】\n64位 CPU的最大寻址空间为 2^64 byte,即16TB\n实际应用中,64位版本的Win7支持8Gb-192GB内存；64位版本的Win10支持128GB~2IB内存\n","date":"2025-08-13T00:00:00Z","image":"http://localhost:1313/p/%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86%E5%A4%8D%E7%9B%98%E7%AC%94%E8%AE%B0/1_hu_5fe8a17fbe587ac8.png","permalink":"http://localhost:1313/p/%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86%E5%A4%8D%E7%9B%98%E7%AC%94%E8%AE%B0/","title":"【加密和解密】| 基础篇"}]